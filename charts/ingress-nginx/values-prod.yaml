# Authentication method: "pod-identity" or "irsa"
authMethod: "pod-identity"

# Load balancer configuration
loadBalancer:
  # Set to "internal" for internal load balancer, "internet-facing" for public
  scheme: "internal"
  # Specify VPC subnets for load balancer placement
  subnets:
    # Private subnets for internal load balancer (multi-AZ for HA)
    - "subnet-12345678"  # Replace with your private subnet ID (AZ-a)
    - "subnet-87654321"  # Replace with your private subnet ID (AZ-b)
    - "subnet-11223344"  # Replace with your private subnet ID (AZ-c)
  # Optional: Specify VPC for additional security
  vpc: "vpc-abcdef123"   # Replace with your VPC ID

# SSL/TLS Certificate configuration
ssl:
  # Enable SSL termination at the load balancer level
  enabled: true
  # ACM certificate ARN for SSL termination
  certificateArn: "arn:aws:acm:us-east-1:ACCOUNT_ID:certificate/12345678-1234-1234-1234-123456789012"
  # SSL policy for the load balancer
  sslPolicy: "ELBSecurityPolicy-TLS-1-2-2017-01"
  # Additional certificate ARNs for multi-domain support
  additionalCertificates: []
    # - "arn:aws:acm:us-east-1:ACCOUNT_ID:certificate/87654321-4321-4321-4321-210987654321"

controller:
  replicaCount: 3
  
  # Ingress class configuration
  ingressClassResource:
    name: nginx
    enabled: true
    default: false
  
  # Service configuration for internal load balancer with SSL
  service:
    type: LoadBalancer
    annotations:
      # Use Network Load Balancer
      service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
      # Internal load balancer
      service.beta.kubernetes.io/aws-load-balancer-scheme: "internal"
      # Specify subnets for load balancer (multi-AZ)
      service.beta.kubernetes.io/aws-load-balancer-subnets: "subnet-12345678,subnet-87654321,subnet-11223344"
      # Cross-zone load balancing
      service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
      # SSL Certificate configuration
      service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:us-east-1:ACCOUNT_ID:certificate/12345678-1234-1234-1234-123456789012"
      service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
      service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: "ELBSecurityPolicy-TLS-1-2-2017-01"
      # Backend protocol for SSL termination
      service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
      # Health check configuration
      service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: "http"
      service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: "/healthz"
      service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: "10254"
      service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: "10"
      service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: "6"
      service.beta.kubernetes.io/aws-load-balancer-healthy-threshold: "2"
      service.beta.kubernetes.io/aws-load-balancer-unhealthy-threshold: "2"
      # Connection draining
      service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"
      service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "300"
      # Additional tags
      service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: "Environment=prod,Project=eks-addons,CostCenter=production"
      # Access logging (optional)
      service.beta.kubernetes.io/aws-load-balancer-access-log-enabled: "true"
      service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name: "my-nlb-access-logs"
      service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix: "ingress-nginx"
    
    # Configure both HTTP and HTTPS ports
    ports:
      http:
        port: 80
        protocol: TCP
        targetPort: http
      https:
        port: 443
        protocol: TCP
        targetPort: http  # SSL terminated at LB, backend uses HTTP
    
    # External traffic policy for preserving source IP
    externalTrafficPolicy: Local
    
    # Load balancer source ranges (restrict access to internal networks)
    loadBalancerSourceRanges:
      - "10.0.0.0/8"     # Private networks
      - "172.16.0.0/12"  # Private networks
      - "192.168.0.0/16" # Private networks
  
  # Metrics configuration
  metrics:
    enabled: true
    service:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "10254"
    serviceMonitor:
      enabled: true
      namespace: monitoring
      interval: 30s
  
  # Autoscaling configuration
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  
  # Service account configuration
  serviceAccount:
    create: true
    name: ingress-nginx
    annotations:
      # IRSA annotation (used when authMethod is "irsa")
      eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT_ID:role/EKS-IngressNginx-Role-prod"
      # Pod Identity annotations (used when authMethod is "pod-identity")
      eks.amazonaws.com/pod-identity-association-role-arn: "arn:aws:iam::ACCOUNT_ID:role/EKS-IngressNginx-Role-prod"
  
  # Resource configuration - higher for production
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 200m
      memory: 256Mi
  
  # Node placement
  nodeSelector:
    kubernetes.io/os: linux
  
  # Tolerations for system nodes
  tolerations:
    - key: "CriticalAddonsOnly"
      operator: "Exists"
  
  # Affinity for better distribution across AZs
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          preference:
            matchExpressions:
              - key: eks.amazonaws.com/nodegroup
                operator: In
                values: ["system"]
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: ingress-nginx
          topologyKey: kubernetes.io/hostname
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                app.kubernetes.io/name: ingress-nginx
            topologyKey: topology.kubernetes.io/zone
  
  # Configuration for internal access with SSL
  config:
    # Enable real IP forwarding
    use-forwarded-headers: "true"
    compute-full-forwarded-for: "true"
    use-proxy-protocol: "false"
    # SSL configuration - SSL terminated at LB
    ssl-redirect: "false"
    force-ssl-redirect: "false"
    # Trust X-Forwarded-Proto header from load balancer
    use-forwarded-headers: "true"
    # Enable HSTS when behind SSL terminating load balancer
    hsts: "true"
    hsts-max-age: "31536000"
    hsts-include-subdomains: "true"
    # Performance tuning
    worker-processes: "auto"
    worker-connections: "16384"
    max-worker-open-files: "65536"
    # Timeouts
    keep-alive-requests: "10000"
    upstream-keepalive-connections: "320"
    upstream-keepalive-requests: "10000"
    # Buffer sizes
    client-body-buffer-size: "128k"
    client-header-buffer-size: "1k"
    large-client-header-buffers: "4 8k"
    # Logging
    log-format-upstream: '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" $request_length $request_time [$proxy_upstream_name] [$proxy_alternative_upstream_name] $upstream_addr $upstream_response_length $upstream_response_time $upstream_status $req_id'
    # Rate limiting
    limit-rate-after: "1024"
    limit-rate: "1024"
  
  # Pod disruption budget
  podDisruptionBudget:
    enabled: true
    minAvailable: 2

# Pod Identity specific configuration
podIdentity:
  enabled: true
  roleArn: "arn:aws:iam::ACCOUNT_ID:role/EKS-IngressNginx-Role-prod"

# Default backend configuration
defaultBackend:
  enabled: true
  image:
    repository: registry.k8s.io/defaultbackend-amd64
    tag: "1.5"
  replicaCount: 2
  resources:
    limits:
      cpu: 20m
      memory: 40Mi
    requests:
      cpu: 10m
      memory: 20Mi
  podDisruptionBudget:
    enabled: true
    minAvailable: 1

# Production-specific monitoring and logging
monitoring:
  enabled: true
  
logging:
  level: info
