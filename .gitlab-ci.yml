# GitLab CI/CD Pipeline for EKS Add-ons
#
# This pipeline supports selective chart installation and uninstallation using environment variables:
#
# Chart Installation Control Variables (set to "false", "0", or "no" to disable):
#   INSTALL_AWS_EFS_CSI_DRIVER     - Controls aws-efs-csi-driver chart installation
#   INSTALL_EXTERNAL_SECRETS_OPERATOR - Controls external-secrets-operator chart installation
#   INSTALL_INGRESS_NGINX          - Controls ingress-nginx chart installation
#   INSTALL_POD_IDENTITY           - Controls pod-identity chart installation
#   INSTALL_SECRETS_STORE_CSI_DRIVER - Controls secrets-store-csi-driver chart installation
#   INSTALL_CLUSTER_AUTOSCALER     - Controls cluster-autoscaler chart installation
#   INSTALL_METRICS_SERVER         - Controls metrics-server chart installation
#   INSTALL_EXTERNAL_DNS           - Controls external-dns chart installation
#
# Chart Uninstallation Control Variables (set to "true", "1", or "yes" to enable):
#   UNINSTALL_AWS_EFS_CSI_DRIVER     - Controls aws-efs-csi-driver chart uninstallation
#   UNINSTALL_EXTERNAL_SECRETS_OPERATOR - Controls external-secrets-operator chart uninstallation
#   UNINSTALL_INGRESS_NGINX          - Controls ingress-nginx chart uninstallation
#   UNINSTALL_POD_IDENTITY           - Controls pod-identity chart uninstallation
#   UNINSTALL_SECRETS_STORE_CSI_DRIVER - Controls secrets-store-csi-driver chart uninstallation
#   UNINSTALL_CLUSTER_AUTOSCALER     - Controls cluster-autoscaler chart uninstallation
#   UNINSTALL_METRICS_SERVER         - Controls metrics-server chart uninstallation
#   UNINSTALL_EXTERNAL_DNS           - Controls external-dns chart uninstallation
#
# Environment Variables:
#   HELM_RELEASES_DEV              - Comma-separated list of charts for dev (optional)
#   HELM_RELEASES_PROD             - Comma-separated list of charts for prod (optional)
#   DEV_KUBECONFIG_B64             - Base64 encoded kubeconfig for dev cluster
#   PROD_KUBECONFIG_B64            - Base64 encoded kubeconfig for prod cluster
#
# Namespace Override Variables:
#   HELM_NAMESPACE_AWS_EFS_CSI_DRIVER     - Override namespace for EFS CSI driver
#   HELM_NAMESPACE_EXTERNAL_SECRETS_OPERATOR - Override namespace for External Secrets
#   HELM_NAMESPACE_INGRESS_NGINX          - Override namespace for Ingress NGINX
#   HELM_NAMESPACE_POD_IDENTITY           - Override namespace for Pod Identity
#   HELM_NAMESPACE_SECRETS_STORE_CSI_DRIVER - Override namespace for Secrets Store CSI Driver
#   HELM_NAMESPACE_CLUSTER_AUTOSCALER - Override namespace for Cluster Autoscaler
#   HELM_NAMESPACE_METRICS_SERVER    - Override namespace for Metrics Server
#   HELM_NAMESPACE_EXTERNAL_DNS      - Override namespace for External DNS
#
# Usage Examples:
#   Installation:
#     - Deploy all charts: Run deploy:helm:dev or deploy:helm:prod
#     - Deploy specific chart: Run deploy:efs-csi:dev or deploy:external-secrets:prod
#     - Skip a chart: Set INSTALL_INGRESS_NGINX=false in CI/CD variables
#   
#   Uninstallation:
#     - Uninstall all marked charts: Run uninstall:helm:dev or uninstall:helm:prod
#     - Uninstall specific chart: Run uninstall:efs-csi:dev or uninstall:external-secrets:prod
#     - Mark chart for uninstall: Set UNINSTALL_INGRESS_NGINX=true in CI/CD variables
#
# Safety Notes:
#   - Uninstall jobs require manual trigger for safety
#   - Individual chart uninstalls include confirmation prompts
#   - Charts are uninstalled in reverse order to handle dependencies
#

stages:
  - validate
  - plan
  - deploy
  - verify
  - uninstall
  - status

default:
  image: alpine:3.20
  before_script:
    - apk add --no-cache bash curl git jq yq kubectl helm
    - mkdir -p ~/.kube
    - echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
    - export KUBECONFIG=~/.kube/config
    - helm version
    - kubectl version --client

validate:helm:
  stage: validate
  script:
    - |
      echo "üß© Linting Helm charts..."
      
      # Function to check if chart should be validated
      should_validate_chart() {
        local chart_name=$1
        local enable_var="INSTALL_$(echo $chart_name | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        local enable_value=${!enable_var}
        
        # Default to true if variable not set
        if [ -z "$enable_value" ]; then
          return 0
        fi
        
        # Check if explicitly disabled
        if [ "$enable_value" = "false" ] || [ "$enable_value" = "0" ] || [ "$enable_value" = "no" ]; then
          return 1
        fi
        
        return 0
      }
      
      LINT_ERRORS=0
      for chart in charts/*; do
        [ -d "$chart" ] || continue
        chart_name=$(basename "$chart")
        
        if should_validate_chart "$chart_name"; then
          echo "‚úÖ Linting $chart ..."
          if ! helm lint "$chart"; then
            echo "‚ùå Lint failed for $chart"
            LINT_ERRORS=$((LINT_ERRORS + 1))
          fi
        else
          echo "‚è≠Ô∏è  Skipping lint for $chart (disabled)"
        fi
      done
      
      if [ $LINT_ERRORS -gt 0 ]; then
        echo "‚ùå $LINT_ERRORS chart(s) failed linting"
        exit 1
      fi
      
      echo "‚úÖ All enabled charts passed linting"
  only: [merge_requests, main]

validate:kustomize:
  stage: validate
  script:
    - echo "üß© Rendering Kustomize overlays..."
    - for env in dev prod; do
        echo "Rendering environment: $env";
        kubectl kustomize k8s-resources/environments/$env > /tmp/$env.yaml;
        test -s /tmp/$env.yaml;
      done
  artifacts:
    paths:
      - /tmp/dev.yaml
      - /tmp/prod.yaml
  only: [merge_requests, main]

plan:
  stage: plan
  script:
    - echo "üîç Kustomize diff for dev"
    - kubectl diff -k k8s-resources/environments/dev || true
  only: [merge_requests]
  when: manual

.deploy_helm_hybrid:
  stage: deploy
  script:
    - |
      echo "üöÄ Deploying Helm add-ons for $ENVIRONMENT..."
      
      # Function to check if chart should be installed
      should_install_chart() {
        local chart_name=$1
        local enable_var="INSTALL_$(echo $chart_name | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        local enable_value=${!enable_var}
        
        # Default to true if variable not set
        if [ -z "$enable_value" ]; then
          return 0
        fi
        
        # Check if explicitly disabled
        if [ "$enable_value" = "false" ] || [ "$enable_value" = "0" ] || [ "$enable_value" = "no" ]; then
          return 1
        fi
        
        return 0
      }
      
      # Determine which charts to deploy
      if [ -z "$HELM_RELEASES" ]; then
        echo "No HELM_RELEASES variable defined. Auto-detecting charts..."
        mapfile -t ALL_RELEASES < <(find charts -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
      else
        IFS=',' read -ra ALL_RELEASES <<< "${HELM_RELEASES}"
      fi
      
      # Filter charts based on installation flags
      RELEASES=()
      for release in "${ALL_RELEASES[@]}"; do
        if should_install_chart "$release"; then
          RELEASES+=("$release")
          echo "‚úÖ Chart '$release' will be installed"
        else
          echo "‚è≠Ô∏è  Chart '$release' will be skipped (disabled)"
        fi
      done
      
      if [ ${#RELEASES[@]} -eq 0 ]; then
        echo "‚ö†Ô∏è  No charts to install. All charts are disabled or none found."
        exit 0
      fi
      
      echo ""
      echo "üìã Charts to install: ${RELEASES[*]}"
      echo ""

      for release in "${RELEASES[@]}"; do
        CHART_DIR="charts/${release}"
        RELEASE_NAME=$(basename "$release")
        NS_VAR="HELM_NAMESPACE_$(echo $RELEASE_NAME | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        NAMESPACE=${!NS_VAR:-$RELEASE_NAME}
        VALUES_FILE="$CHART_DIR/values-${ENVIRONMENT}.yaml"

        echo "-------------------------------------------------"
        echo "Helm Upgrade: $RELEASE_NAME in ns=$NAMESPACE (chart=$CHART_DIR)"
        echo "Using values: $VALUES_FILE"
        echo "-------------------------------------------------"

        # Check if values file exists
        if [ ! -f "$VALUES_FILE" ]; then
          echo "‚ö†Ô∏è  Values file not found: $VALUES_FILE"
          echo "Skipping chart: $RELEASE_NAME"
          continue
        fi

        # Check if chart has dependencies
        if [ -f "$CHART_DIR/Chart.yaml" ] && grep -q "dependencies:" "$CHART_DIR/Chart.yaml"; then
          echo "üì¶ Chart has dependencies, extracting repositories..."
          
          # Extract unique repository URLs from Chart.yaml
          REPOS=$(grep -A 10 "dependencies:" "$CHART_DIR/Chart.yaml" | grep "repository:" | awk '{print $2}' | tr -d '"' | sort -u)
          
          REPOS_ADDED=0
          for repo_url in $REPOS; do
            # Generate a simple repo name from the URL
            repo_name=$(echo "$repo_url" | sed 's|https://||' | sed 's|http://||' | sed 's|/.*||' | tr '.' '-')
            echo "  ‚Üí Adding repository: $repo_name ($repo_url)"
            helm repo add "$repo_name" "$repo_url" --insecure-skip-tls-verify || true
            REPOS_ADDED=$((REPOS_ADDED + 1))
          done
          
          # Only update and build if repositories were added
          if [ $REPOS_ADDED -gt 0 ]; then
            echo "Updating $REPOS_ADDED repository/repositories..."
            helm repo update --insecure-skip-tls-verify || true
            
            echo "Building chart dependencies..."
            helm dependency build "$CHART_DIR" --skip-refresh || {
              echo "‚ö†Ô∏è  Dependency build failed, trying with update..."
              helm dependency update "$CHART_DIR" || true
            }
          else
            echo "‚ö†Ô∏è  No repositories found in Chart.yaml"
          fi
        fi

        helm upgrade --install "$RELEASE_NAME" "$CHART_DIR" \
          -n "$NAMESPACE" --create-namespace \
          -f "$VALUES_FILE" \
          --wait --timeout 10m

        echo ""
        kubectl -n "$NAMESPACE" get pods
        echo ""
      done
  only: [main]
  when: manual

# Template for individual chart deployment
.deploy_single_chart:
  stage: deploy
  script:
    - |
      CHART_NAME="$CHART_TO_DEPLOY"
      CHART_DIR="charts/${CHART_NAME}"
      RELEASE_NAME="$CHART_NAME"
      NS_VAR="HELM_NAMESPACE_$(echo $RELEASE_NAME | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
      NAMESPACE=${!NS_VAR:-$RELEASE_NAME}
      VALUES_FILE="$CHART_DIR/values-${ENVIRONMENT}.yaml"
      
      echo "üöÄ Deploying single chart: $CHART_NAME for $ENVIRONMENT..."
      
      if [ ! -d "$CHART_DIR" ]; then
        echo "‚ùå Chart directory not found: $CHART_DIR"
        exit 1
      fi
      
      if [ ! -f "$VALUES_FILE" ]; then
        echo "‚ùå Values file not found: $VALUES_FILE"
        exit 1
      fi
      
      echo "-------------------------------------------------"
      echo "Helm Upgrade: $RELEASE_NAME in ns=$NAMESPACE (chart=$CHART_DIR)"
      echo "Using values: $VALUES_FILE"
      echo "-------------------------------------------------"
      
      # Check if chart has dependencies
      if [ -f "$CHART_DIR/Chart.yaml" ] && grep -q "dependencies:" "$CHART_DIR/Chart.yaml"; then
        echo "üì¶ Chart has dependencies, extracting repositories..."
        
        # Extract unique repository URLs from Chart.yaml
        REPOS=$(grep -A 10 "dependencies:" "$CHART_DIR/Chart.yaml" | grep "repository:" | awk '{print $2}' | tr -d '"' | sort -u)
        
        REPOS_ADDED=0
        for repo_url in $REPOS; do
          # Generate a simple repo name from the URL
          repo_name=$(echo "$repo_url" | sed 's|https://||' | sed 's|http://||' | sed 's|/.*||' | tr '.' '-')
          echo "  ‚Üí Adding repository: $repo_name ($repo_url)"
          helm repo add "$repo_name" "$repo_url" --insecure-skip-tls-verify || true
          REPOS_ADDED=$((REPOS_ADDED + 1))
        done
        
        # Only update and build if repositories were added
        if [ $REPOS_ADDED -gt 0 ]; then
          echo "Updating $REPOS_ADDED repository/repositories..."
          helm repo update --insecure-skip-tls-verify || true
          
          echo "Building chart dependencies..."
          helm dependency build "$CHART_DIR" --skip-refresh || {
            echo "‚ö†Ô∏è  Dependency build failed, trying with update..."
            helm dependency update "$CHART_DIR" || true
          }
        else
          echo "‚ö†Ô∏è  No repositories found in Chart.yaml"
        fi
      fi

      helm upgrade --install "$RELEASE_NAME" "$CHART_DIR" \
        -n "$NAMESPACE" --create-namespace \
        -f "$VALUES_FILE" \
        --wait --timeout 10m
      
      echo ""
      kubectl -n "$NAMESPACE" get pods
  only: [main]
  when: manual

# All charts deployment jobs
deploy:helm:dev:
  extends: .deploy_helm_hybrid
  variables:
    ENVIRONMENT: dev
    HELM_RELEASES: $HELM_RELEASES_DEV
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:helm:prod:
  extends: .deploy_helm_hybrid
  variables:
    ENVIRONMENT: prod
    HELM_RELEASES: $HELM_RELEASES_PROD
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

# Individual chart deployment jobs for dev
deploy:efs-csi:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: aws-efs-csi-driver
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:external-secrets:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: external-secrets-operator
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:ingress-nginx:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: ingress-nginx
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:pod-identity:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: pod-identity
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:secrets-store:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: secrets-store-csi-driver
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:cluster-autoscaler:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: cluster-autoscaler
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:metrics-server:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: metrics-server
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

deploy:external-dns:dev:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_DEPLOY: external-dns
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

# Individual chart deployment jobs for prod
deploy:efs-csi:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: aws-efs-csi-driver
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

deploy:external-secrets:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: external-secrets-operator
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

deploy:ingress-nginx:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: ingress-nginx
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

deploy:pod-identity:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: pod-identity
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

deploy:secrets-store:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: secrets-store-csi-driver
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

deploy:cluster-autoscaler:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: cluster-autoscaler
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

deploy:metrics-server:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: metrics-server
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

deploy:external-dns:prod:
  extends: .deploy_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_DEPLOY: external-dns
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

# Template for uninstalling all charts
.uninstall_helm_all:
  stage: uninstall
  script:
    - |
      echo "üóëÔ∏è  Checking for charts to uninstall in $ENVIRONMENT..."
      
      # Function to check if chart should be uninstalled
      should_uninstall_chart() {
        local chart_name=$1
        local uninstall_var="UNINSTALL_$(echo $chart_name | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        local uninstall_value=${!uninstall_var}
        
        # Default to false if variable not set (safety first)
        if [ -z "$uninstall_value" ]; then
          return 1
        fi
        
        # Check if explicitly enabled
        if [ "$uninstall_value" = "true" ] || [ "$uninstall_value" = "1" ] || [ "$uninstall_value" = "yes" ]; then
          return 0
        fi
        
        return 1
      }
      
      # Function to uninstall a chart if it exists
      uninstall_chart_if_exists() {
        local chart_name=$1
        local release_name="$chart_name"
        local ns_var="HELM_NAMESPACE_$(echo $release_name | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        local namespace=${!ns_var:-$release_name}
        
        echo "Checking if $release_name exists in namespace $namespace..."
        
        if helm status "$release_name" -n "$namespace" >/dev/null 2>&1; then
          echo "-------------------------------------------------"
          echo "Uninstalling: $release_name from namespace $namespace"
          echo "-------------------------------------------------"
          
          if helm uninstall "$release_name" -n "$namespace" --wait --timeout 5m; then
            echo "‚úÖ Successfully uninstalled $release_name"
          else
            echo "‚ùå Failed to uninstall $release_name"
            return 1
          fi
        else
          echo "‚ÑπÔ∏è  Release '$release_name' not found in namespace '$namespace', skipping"
        fi
        
        return 0
      }
      
      # Determine which charts to check for uninstallation
      if [ -z "$HELM_RELEASES" ]; then
        echo "No HELM_RELEASES variable defined. Checking all known charts..."
        mapfile -t ALL_RELEASES < <(find charts -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
      else
        IFS=',' read -ra ALL_RELEASES <<< "${HELM_RELEASES}"
      fi
      
      # Check each chart for uninstall flag and uninstall if marked
      UNINSTALLED_COUNT=0
      FAILED_COUNT=0
      
      for release in "${ALL_RELEASES[@]}"; do
        if should_uninstall_chart "$release"; then
          echo "üóëÔ∏è  Chart '$release' is marked for uninstallation"
          if uninstall_chart_if_exists "$release"; then
            UNINSTALLED_COUNT=$((UNINSTALLED_COUNT + 1))
          else
            FAILED_COUNT=$((FAILED_COUNT + 1))
          fi
          echo ""
        else
          echo "‚è≠Ô∏è  Chart '$release' not marked for uninstall, skipping"
        fi
      done
      
      echo "üèÅ Uninstall process completed"
      echo "   Uninstalled: $UNINSTALLED_COUNT charts"
      echo "   Failed: $FAILED_COUNT charts"
      
      if [ $FAILED_COUNT -gt 0 ]; then
        exit 1
      fi
  only: [main]
  when: manual

# Template for uninstalling a single chart
.uninstall_single_chart:
  stage: uninstall
  script:
    - |
      CHART_NAME="$CHART_TO_UNINSTALL"
      RELEASE_NAME="$CHART_NAME"
      NS_VAR="HELM_NAMESPACE_$(echo $RELEASE_NAME | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
      NAMESPACE=${!NS_VAR:-$RELEASE_NAME}
      
      echo "üóëÔ∏è  Uninstalling chart: $CHART_NAME from $ENVIRONMENT..."
      
      # Check if release exists
      if ! helm status "$RELEASE_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
        echo "‚ÑπÔ∏è  Release '$RELEASE_NAME' not found in namespace '$NAMESPACE'"
        echo "Nothing to uninstall"
        exit 0
      fi
      
      echo "-------------------------------------------------"
      echo "Uninstalling: $RELEASE_NAME from namespace $NAMESPACE"
      echo "-------------------------------------------------"
      
      # Show current status before uninstalling
      echo "Current release status:"
      helm status "$RELEASE_NAME" -n "$NAMESPACE" --short
      
      # Show resources that will be deleted
      echo ""
      echo "Resources to be deleted:"
      kubectl get all -n "$NAMESPACE" -l "app.kubernetes.io/instance=$RELEASE_NAME" 2>/dev/null || echo "No resources found with instance label"
      
      echo ""
      echo "Proceeding with uninstallation..."
      
      # Uninstall the release
      if helm uninstall "$RELEASE_NAME" -n "$NAMESPACE" --wait --timeout 10m; then
        echo "‚úÖ Successfully uninstalled $RELEASE_NAME"
        
        # Check for remaining resources
        echo ""
        echo "Checking for remaining resources in namespace $NAMESPACE..."
        REMAINING_RESOURCES=$(kubectl get all -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
        
        if [ "$REMAINING_RESOURCES" -eq 0 ]; then
          echo "‚ÑπÔ∏è  Namespace $NAMESPACE appears empty"
          echo "üí° Consider deleting the namespace if no longer needed:"
          echo "   kubectl delete namespace $NAMESPACE"
        else
          echo "‚ÑπÔ∏è  $REMAINING_RESOURCES resources remain in namespace $NAMESPACE"
        fi
      else
        echo "‚ùå Failed to uninstall $RELEASE_NAME"
        exit 1
      fi
  only: [main]
  when: manual

# All charts uninstall jobs
uninstall:helm:dev:
  extends: .uninstall_helm_all
  variables:
    ENVIRONMENT: dev
    HELM_RELEASES: $HELM_RELEASES_DEV
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:helm:prod:
  extends: .uninstall_helm_all
  variables:
    ENVIRONMENT: prod
    HELM_RELEASES: $HELM_RELEASES_PROD
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

# Individual chart uninstall jobs for dev
uninstall:efs-csi:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: aws-efs-csi-driver
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:external-secrets:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: external-secrets-operator
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:ingress-nginx:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: ingress-nginx
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:pod-identity:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: pod-identity
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:secrets-store:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: secrets-store-csi-driver
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:cluster-autoscaler:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: cluster-autoscaler
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:metrics-server:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: metrics-server
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

uninstall:external-dns:dev:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: dev
    CHART_TO_UNINSTALL: external-dns
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

# Individual chart uninstall jobs for prod
uninstall:efs-csi:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: aws-efs-csi-driver
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

uninstall:external-secrets:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: external-secrets-operator
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

uninstall:ingress-nginx:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: ingress-nginx
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

uninstall:pod-identity:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: pod-identity
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

uninstall:secrets-store:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: secrets-store-csi-driver
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

uninstall:cluster-autoscaler:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: cluster-autoscaler
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

uninstall:metrics-server:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: metrics-server
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

uninstall:external-dns:prod:
  extends: .uninstall_single_chart
  variables:
    ENVIRONMENT: prod
    CHART_TO_UNINSTALL: external-dns
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64

.deploy_kustomize:
  stage: deploy
  script:
    - echo "üì¶ Applying native Kustomize resources for $ENVIRONMENT..."
    - kubectl apply -k k8s-resources/environments/$ENVIRONMENT
  only: [main]
  when: manual

deploy:kustomize:dev:
  extends: .deploy_kustomize
  variables:
    ENVIRONMENT: dev
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64
  needs: ["deploy:helm:dev"]

deploy:kustomize:prod:
  extends: .deploy_kustomize
  variables:
    ENVIRONMENT: prod
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64
  needs: ["deploy:helm:prod"]

.verify_template:
  stage: verify
  script:
    - echo "‚úÖ Verifying cluster state for $ENVIRONMENT ..."
    - kubectl get ns
    - kubectl get ingress -A
    - kubectl get pods -A | grep -E "external-secrets|nginx|efs|pod-identity|secrets-store|cluster-autoscaler|metrics-server|external-dns" || true
    - kubectl get sc,pv,pvc
  only: [main]
  when: manual

verify:dev:
  extends: .verify_template
  variables:
    ENVIRONMENT: dev
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64
  needs: ["deploy:kustomize:dev"]

verify:prod:
  extends: .verify_template
  variables:
    ENVIRONMENT: prod
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64
  needs: ["deploy:kustomize:prod"]

# Template for checking chart status
.status_template:
  stage: status
  script:
    - |
      echo "üìä Checking chart status for $ENVIRONMENT..."
      echo ""
      
      # Function to check installation status
      check_chart_status() {
        local chart_name=$1
        local release_name="$chart_name"
        local ns_var="HELM_NAMESPACE_$(echo $release_name | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        local namespace=${!ns_var:-$release_name}
        local install_var="INSTALL_$(echo $chart_name | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        local uninstall_var="UNINSTALL_$(echo $chart_name | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        local install_value=${!install_var}
        local uninstall_value=${!uninstall_var}
        
        echo "Chart: $chart_name"
        echo "  Release: $release_name"
        echo "  Namespace: $namespace"
        
        # Check installation flag
        if [ -z "$install_value" ] || [ "$install_value" != "false" ] && [ "$install_value" != "0" ] && [ "$install_value" != "no" ]; then
          echo "  Install Flag: ‚úÖ enabled"
        else
          echo "  Install Flag: ‚ùå disabled"
        fi
        
        # Check uninstall flag
        if [ "$uninstall_value" = "true" ] || [ "$uninstall_value" = "1" ] || [ "$uninstall_value" = "yes" ]; then
          echo "  Uninstall Flag: üóëÔ∏è  marked for removal"
        else
          echo "  Uninstall Flag: ‚è≠Ô∏è  not marked"
        fi
        
        # Check actual deployment status
        if helm status "$release_name" -n "$namespace" >/dev/null 2>&1; then
          CHART_VERSION=$(helm list -n "$namespace" -f "^${release_name}$" -o json | jq -r '.[0].chart // "unknown"')
          APP_VERSION=$(helm list -n "$namespace" -f "^${release_name}$" -o json | jq -r '.[0].app_version // "unknown"')
          STATUS=$(helm list -n "$namespace" -f "^${release_name}$" -o json | jq -r '.[0].status // "unknown"')
          echo "  Deployment Status: üöÄ deployed"
          echo "  Chart Version: $CHART_VERSION"
          echo "  App Version: $APP_VERSION"
          echo "  Status: $STATUS"
          
          # Check pod status
          POD_COUNT=$(kubectl get pods -n "$namespace" -l "app.kubernetes.io/instance=$release_name" --no-headers 2>/dev/null | wc -l)
          READY_PODS=$(kubectl get pods -n "$namespace" -l "app.kubernetes.io/instance=$release_name" --no-headers 2>/dev/null | grep -c "Running\|Completed" || echo "0")
          echo "  Pods: $READY_PODS/$POD_COUNT ready"
        else
          echo "  Deployment Status: ‚ùå not deployed"
        fi
        
        echo ""
      }
      
      # Get all charts to check
      if [ -z "$HELM_RELEASES" ]; then
        echo "Checking all known charts..."
        mapfile -t ALL_RELEASES < <(find charts -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
      else
        IFS=',' read -ra ALL_RELEASES <<< "${HELM_RELEASES}"
      fi
      
      echo "Charts to check: ${ALL_RELEASES[*]}"
      echo ""
      echo "=================================================="
      
      for release in "${ALL_RELEASES[@]}"; do
        check_chart_status "$release"
      done
      
      echo "=================================================="
      echo ""
      echo "üìã Summary:"
      echo "Environment: $ENVIRONMENT"
      echo "Total charts checked: ${#ALL_RELEASES[@]}"
      
      # Count deployed charts
      DEPLOYED_COUNT=0
      for release in "${ALL_RELEASES[@]}"; do
        ns_var="HELM_NAMESPACE_$(echo $release | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
        namespace=${!ns_var:-$release}
        if helm status "$release" -n "$namespace" >/dev/null 2>&1; then
          DEPLOYED_COUNT=$((DEPLOYED_COUNT + 1))
        fi
      done
      
      echo "Deployed charts: $DEPLOYED_COUNT/${#ALL_RELEASES[@]}"
  only: [main]
  when: manual

# Status checking jobs
status:dev:
  extends: .status_template
  variables:
    ENVIRONMENT: dev
    HELM_RELEASES: $HELM_RELEASES_DEV
    KUBECONFIG_DATA: $DEV_KUBECONFIG_B64

status:prod:
  extends: .status_template
  variables:
    ENVIRONMENT: prod
    HELM_RELEASES: $HELM_RELEASES_PROD
    KUBECONFIG_DATA: $PROD_KUBECONFIG_B64
